# 【原理】React事件机制解析.md

非常重要 

工作:
1. 假设你使用的是React17以前的react版本 react16.8, 那么你可能会遇到一些关于事件上的问题 以及和相关库的兼容性的问题, 如果你不懂事件机制, 那你没法解决

面试:
1. 目前只要涉及到react的面试题【大厂 2W --- 】: 事件机制, fiber架构, react调度机制, 优先级概念, commit 以及 render两个阶段 以及hooks原理


首先 我说过 React的JSX 写的代码不是真实dom babel编译成React.createElement  他会被react执行 从而在页面中生成真实dom

其次 所有的标签属性都不是真实的dom属性, 而是会被react进行处理 最终反应到真实dom身上去


react 为了节约性能以及实现动态监听, react使用事件委托的机制

假设我现在有1000个dom, 与其我绑定1000个dom事件

不如我给这1000个dom的父级绑定事件, 给父级绑定的话 只需要绑定一个事件就ok了, event.target ---> 指向真正触发事件的人

react把事件绑定在了对应的 root 元素上, 当某个真实dom触发事件以后, dom事件会随着事件冒泡 一直冒到root元素上, root元素对应的事件处理函数又可以通过event.target知道真正触发事件的元素是谁 

那其实就意味着 对应的jsx所转化的真实dom身上不会绑定任何的真实事件， react会把jsx上所书写的对应的和事件有关的标签属性收集起来 找个地方存起来

最终真实dom在页面生成, 当我们点击对应的真实dom时 事件会冒泡 事件冒泡是不需要绑定真实dom事件也会冒泡的 最终会冒泡到root 然后root来进行事件的处理



## 第二个我要讲的是 react的事件池机制 【在react17以后 是不会发生了, react17以后取消了事件池机制】

1. react里的标签属性事件 对应的event 是哪来的？？ 【react 捏给你的, 和真实dom没有半毛钱关系】
2. 在16.8以及之前的版本 react为了更好的性能考虑会尝试重用事件 
3. react会保存引用 只是修改对应的属性值

**基于React的事件池机制, 只要你公司用的还是17以下的代码, 你都要注意不要在异步环境下访问事件源对象的属性**

event.xxx 变成null了  不小心写进异步场景了 自己还没注意 同时访问属性是null了 不知道为什么？？ 

**如果你非得要在react16.8里去异步访问event, 也有办法, react说你调用: e.persist(), 会取消事件池的重用机制** 




