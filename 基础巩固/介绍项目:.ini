介绍项目:

如果说是实习生, 可以说是在学校里因为班级有使用飞书做一些必要的数据处理工作「比如统计节假日回家人数以及返校时间之类的」, 然后看到飞书的交互以及各种能力很出色, 于是就自己也尝试实现了一个小型的飞书系统,  如果是已经工作一段时间的, 那就直接说是自己公司在做的产品就好了 功能包括:
1. Canvas绘制表格「使用konva.js 这个canvas绘制开源库」
 - 这里可能会产生第一个问题: 为什么使用canvas？ 而不使用dom？
  答: 因为考虑到当数据量一大, 一个文档可能会有几千行数据, 那此时如果使用dom 可能会造成性能问题, 而canvas则会相对来说性能好上不少
2. 多语言以及明暗主题功能实现「这个只需要讲到i18n这个库就行了 就说用的这个库」
 - 这里也可能会产生2个问题: 
  - 你怎么实现明暗主题的？ 「直接把项目里的代码给他写一遍」
  - 你有没有考虑过根据系统主题自动切换明暗主题这个功能「这个代码里也讲过」
3. 多人协同功能的实现:
 - 这里会产生比较多的问题:
  - 你是怎么做多人协同的:
   首先来讲, 一旦涉及到多人协同方面的功能我门必定要使用的是socket在客户端以及服务端之间建立长链接, 所以我这边在客户端使用了 socket-client.js这个库, 在服务端使用了socket.io这个库, 根据他们各自的api 在客户端和服务端之间建立一条链接并彼此监听对应的message joinroom connect等常规事件, 当客户端进入一个文档时触发joinroom事件 告诉服务端有新用户加入了该文档进行协同操作, 服务端接收到对应信息以后 会直接通过socket主动给在当前文档中的其他客户端发送有人加入的请求, 当客户端产生操作时, 也和之前的joinroom一样更新一个事件给到服务端, 服务端经过确认后发送给其他客户端, 但是基于这个逻辑其中会有一些意外情况发生, 比如说用户的离线操作以及断线重连, 以及多个用户产生对应冲突操作时的处理
  - 你是怎么处理用户冲突的:
   用户产生操作冲突这个并不难处理, 会利用ot.js这个库去做对应的冲突操作, 而在使用ot.js这个库之前 我对ot算法也有了一定的了解 「然后把ot算法的几个原则 课程里详细讲过, 都给面试官说一遍」, 那么我举个最简单的例子, 有个用户改了一个列的列名, 另一个用户直接删除了该列 这两条请求同时提交一个20版本发送给服务端时, 服务端会利用ot.js提供的api 去利用合适的算法来产生一个冲突解决, 而在这个例子里, 服务端会做的是最小代价处理法,  他会将对应的改名操作先应用, 然后将删除操作递交为21版本 再进行删除, 然后广播给所有客户端
  - 什么是ot算法 「这个直接找之前的课件 我笔记当时共享出来了的 写了很多」
  - 你是怎么保证多个客户端和服务端数据的一致性呢:
   这个也很好处理, 要保证客户端和服务端数据的一致性我们只需要考虑好每台客户端的io操作， 一个是自己的输出 我们必须产生一个socket队列 让版本一个一个的推送出去 上一个版本的推送没有得到响应时不推送下一个版本 而不是一窝蜂的全部送出去, 因为一窝蜂都推送出去 可能会由于网速以及带宽的影响导致后发的请求先到服务器 这样就乱套了, 所以这是控制客户端自己的输出, 那么针对服务端过来的输入, 我们必须先看版本是否是正常的, 比如用户本地版本是20， 服务端推送过来的是21 那则是正常的, 如果用户本地版本是21 服务端也推送了一个21。那此时则不正常(这种情况多发生在离线操作以及网络很差的情况下) 在这种情况下, 我们要做的是把客户端本地的操作直接推给服务端 服务端发现这台客户端的版本太落后了又会进入ot.js的冲突解决流程, 然后会给出一个代价最小的新版本返还给当前客户端
  - 怎么做离线操作的:
   离线操作首先涉及到一个新的东西叫做indexeddb, 因为一旦我们脱机, 则所有的操作我们不可能存在内存里, 存在内存里的问题就是用户如果不小心把浏览器关了 或者tab页关掉了 则他当前脱机状态所做的所有编辑都会失效 我们不希望这样的事情发生, 所以我们会存入indexeddb， 用户的每一个操作作为indexeddb的一条记录, 当用户每次操作时写入一条记录, 同时发送版本的时候也是从indexeddb读取. 当脱机以后操作就只会写入indexeddb 而不会发送给服务端， 当网络重新连接上以后, 会把indexeddb里的记录都读出来然后发送给服务端
  - 怎么做撤销回退的
   其实撤销回退是业务上给用户的说明, 在程序逻辑里撤销和回退永远都是一个产生一个新版本的推送, 因为当客户端产生一个操作时 我们会将他操作的新值 以及当前的旧值 以及操作的位置 再加上版本号一起发送给服务端, 同时也会将最近的20步操作都存在内存中, 当用户进行撤销操作时 我们只需要把当前内存里的最近的一个版本号拿出来并将旧值和新值进行替换 以及将版本号+1 然后再次发送给服务端, 服务端只会认为是收到了一个新版本, 同时将这个操作转入回退队列, 回退和撤销也是一样的操作 
4. 我们知道socket其实并不是那么稳定的, 那你如何保证socket连接的稳定性呢
 - 第一个就是socket他有一个默认行为就是当长时间没有连接以后可能会断开, 那么此时我们需要加入一个心跳检测机制来确保socket连接的一个稳定性以确保即使当用户长时间没有操作 整个socket连接也不会断开, 具体的实现方式其实是服务端发送一个小型的消息到客户端 客户端再回复一个很小的消息就ok了, 我们一般会使用数字 比如说服务端发送一个1 客户端响应一个2 就做到了心跳机制
 - 第二个是我们需要融入确认机制 即 当前客户端发送给服务端的数据 服务端是确实收到了, 那就得服务端收到客户端消息并应用成功以后 给当前客户端一个确认回馈, 如果客户端没有收到确认回馈 则表示当前的版本丢包了, 那就会提示用户网络是否有问题 当网络状态良好时 再重新发送版本

5.  像这种多人协同的文档型产品一般都会造成海量的数据, 那么你有没有从哪些角度去提升对应的性能？
 - 第一个首先我们需要使用canvas来替换传统的dom渲染, 因为dom的crud是非常消耗渲染性能的, 而canvas则会规避这个问题, 这个是最基本的提高性能的方式
 - 但是根据用户机器以及浏览器版本的算力不同, 即使使用了canvas 当数据量大的时候 也会造成比较多的卡顿, 所以这里我们需要引入虚拟技术, 比如虚拟滚动以及虚拟列表, 只会渲染用户整个视口的可见区域, 而不会全盘所有渲染
 - 基于上一点我们虽然解决了首次渲染的问题, 但是当用户不断的向下滚动 可能又会 创建出非常海量的数据在canvas上, 那么我们可以针对低版本浏览器和性能不那么好的计算机追加一个数据分片操作, 即卸载掉不处于视口内的数据， 随着用户的滚动 去做加载和卸载数据块
 - 在socket传输的过程中我们也需要考虑一些性能问题, 将整个传输的message都进行压缩成二进制或这其他体积比较小的数据结构, 以提升网络传输性能
 - 在应用版本和离线推送时 我们可以对多个版本进行合并应用以及推送操作, 而避免不必要的视图更新「比如说 我离线很久了, 此时连上网络后 服务端推送过来的版本集合里有 一个是修改列名 后面还有一个是删除列, 那么此时我只需要把这两个版本进行合并 只对视图数据进行一个删除列的操作就好」


上面的信息 包括了 从构建 到 多人协同 到性能优化 等各类流程可能会遇到的问题  可能还有一些细节 当大家在面试中被问到一些我上面没有提及的问题的时候 可以私发给我 我在有空时会再次进行补全。